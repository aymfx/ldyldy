## 常用的缓存淘汰策略

- 先进先出策略 FIFO（First In，First Out）
- 最少使用策略 LFU（Least Frequently Used）
- 最近最少使用策略 LRU（Least Recently Used）

## 链表的特性（对比数组来说）

- 链表的存储方式和数组不一样，如图，数组是连续的一块内存空间，而链表不需要是连续的，只需要零散的内存块串联起来使用

![img](http://www.maymfx.cn/pic/1615186078459-f0d508e2-ec7b-458f-b948-a3279da3045d.jpeg)

- 链表有三种结构
  - **单向链表**
  - **双向链表**
  - 循环列表

- 链表是通过指针将一组零散的内存块串联在一起的，其中内存块被称为结点，每个结点不仅需要存数据还需要存储下个结点的地址

## 单向链表

![img](http://www.maymfx.cn/pic/1615186078470-49420655-01b1-409e-8236-5da2adc6d5f1.jpeg)

- 第一个结点叫做头结点，头结点用来记录链表的基地址
- 最后一个结点叫尾结点，尾结点下一个指针指向的是空地址NULL
- 结点的插入和删除操作是O(1),但是随机访问的操作时间复杂度依然是O(n)

## 循环链表

![img](http://www.maymfx.cn/pic/1615186078479-3585d6d6-3759-4f8e-aa80-8ac149971d62.jpeg)

- **循环链表是一种特殊的单链表**
- 尾结点指向第一个结点的基地址

## 双向链表

![img](http://www.maymfx.cn/pic/1615186078462-840c3cd0-db37-4b13-a1fb-1d20d40f4b71.jpeg)

- 它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。
- 存储相同的数据，双向链表需要的内存空间更多，双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。
- 在某些程度，双向链表的插入和删除操作会比单链表高效简单
  - 删除某个已知结点的前一个结点 （主要是耗时在查找上面）

## 双向循环链表

![img](http://www.maymfx.cn/pic/1615186078494-303a6d57-1b07-4bc5-9733-e806048404eb.jpeg)

## 如何写好链表

### 技巧一：理解指针或引用的含义

- **将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。**
- **p-&next=q。这行代码是说，p 结点中的 next 指针存储了 q 结点的内存地址。**
- **p-&next=p-&next-&next。这行代码表示，p 结点的 next 指针存储了 p 结点的下下一个结点的内存地址**

### 技巧二：警惕指针丢失和内存泄漏

- **插入结点时，一定要注意操作的顺序**
- **删除链表结点时，也一定要记得手动释放内存空间**

### 技巧三：利用哨兵简化实现难度

- **针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理**。

  ![img](http://www.maymfx.cn/pic/1615186100799-b127d372-c085-4e93-9317-d364c16031f1.jpeg)

### 技巧四：重点留意边界条件处理

检查链表代码是否正确的边界条件有这样几个

-  如果链表为空时，代码是否能正常工作？
- 如果链表只包含一个结点时，代码是否能正常工作？
- 如果链表只包含两个结点时，代码是否能正常工作？

- 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？

## 操作:

- 单链表反转
- 链表中环的检测

- 两个有序的链表合并
- 删除链表倒数第 n 个结点

- 求链表的中间结点









































































